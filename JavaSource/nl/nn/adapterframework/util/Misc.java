/*
 * $Log: Misc.java,v $
 * Revision 1.11  2005-09-22 15:54:17  europe\L190409
 * added replace function
 *
 * Revision 1.10  2005/07/19 11:37:40  Gerrit van Brakel <gerrit.van.brakel@ibissource.org>
 * added stream copying functions
 *
 * Revision 1.9  2004/10/26 15:36:36  Gerrit van Brakel <gerrit.van.brakel@ibissource.org>
 * set UTF-8 as default inputstream encoding
 *
 */
package nl.nn.adapterframework.util;

import java.io.*;
import java.net.InetAddress;
import java.net.URL;
import java.net.UnknownHostException;
import java.rmi.server.UID;

/**
 * Miscellanous conversion functions.
 * @version Id
 */
public class Misc {
	public static final String version="$RCSfile: Misc.java,v $ $Revision: 1.11 $ $Date: 2005-09-22 15:54:17 $";
	public static final int BUFFERSIZE=20000;
	public static final String DEFAULT_INPUT_STREAM_ENCODING="UTF-8";

	public static String createSimpleUUID_old() {
		StringBuffer sb = new StringBuffer();
		sb.append(System.currentTimeMillis());
		sb.append('-');
		sb.append(Math.round(Math.random() * 1000000));
		return sb.toString();
	}

	/**
	* Creates a Universally Unique Identifier, via the java.rmi.server.UID class.
	*/
	public static String createSimpleUUID() {
		UID uid = new UID();

		// Replace semi colons by underscores, so IBIS will support it
		String uidString = uid.toString().replace(':', '_');
		return uidString;
	}
	/**
	* Creates a Universally Unique Identifier.
	*
	* Similar to javax.mail.internet.UniqueValue, this implementation
	* generates a unique value by random number, the current
	* time (in milliseconds), and this system's hostname generated by
	* <code>InternetAddress.getLocalAddress()</code>.
	* @return A unique identifier is returned.
	*/
	static public String createUUID() {
		String user = System.getProperty("user.name");
		InetAddress inetAddress = null;
		String ipAddress = null;

		try {
			inetAddress = InetAddress.getLocalHost();
			ipAddress = inetAddress.getHostAddress();
		}

		catch (UnknownHostException uhe) {
			ipAddress = "127.0.0.1";
		}

		StringBuffer s = new StringBuffer();

		//Unique string is <ipaddress>.<currentTime>.<username>.<hashcode>
		s.append(ipAddress).append('.').append(System.currentTimeMillis()).append('.').append(user).append('.').append(
			Math.round(Math.random() * 1000000));

		return s.toString();
	}

	public static void fileToWriter(String filename, Writer writer) throws IOException {
		readerToWriter(new FileReader(filename), writer);
	}
	
	public static void fileToStream(String filename, OutputStream output) throws IOException {
		streamToStream(new FileInputStream(filename), output);
	}
	
	public static void streamToStream(InputStream input, OutputStream output) throws IOException {
		if (input!=null) {
			byte buffer[]=new byte[BUFFERSIZE]; 
				
			int bytesRead;
			while ((bytesRead=input.read(buffer,0,BUFFERSIZE))>0) {
				output.write(buffer,0,bytesRead);
			}
			input.close();
		}
	}

	public static void readerToWriter(Reader reader, Writer writer) throws IOException {
		if (reader!=null) {
			char buffer[]=new char[BUFFERSIZE]; 
				
			int charsRead;
			while ((charsRead=reader.read(buffer,0,BUFFERSIZE))>0) {
				writer.write(buffer,0,charsRead);
			}
			reader.close();
		}
	}

	/**
	 * Please consider using resourceToString() instead of relying on files.
	 */
	public static String fileToString(String fileName) throws IOException {
		return fileToString(fileName, null, false);
	}
	/**
	 * Please consider using resourceToString() instead of relying on files.
	 */
	public static String fileToString(String fileName, String endOfLineString) throws IOException {
		return fileToString(fileName, endOfLineString, false);
	}
	/**
	  * Please consider using resourceToString() instead of relying on files.
	 */
	public static String fileToString(String fileName, String endOfLineString, boolean xmlEncode) throws IOException {
		FileReader reader = new FileReader(fileName);
		try {
			return readerToString(reader, endOfLineString, xmlEncode);
		}
		finally {
			reader.close();
		}
	}
	

	public static String readerToString(Reader reader, String endOfLineString, boolean xmlEncode) throws IOException {
		StringBuffer sb = new StringBuffer();
		int curChar = -1;
		int prevChar = -1;
		while ((curChar = reader.read()) != -1 || prevChar == '\r') {
			if (prevChar == '\r' || curChar == '\n') {
				if (endOfLineString == null) {
					if (prevChar == '\r')
						sb.append((char) prevChar);
					if (curChar == '\n')
						sb.append((char) curChar);
				}
				else {
					sb.append(endOfLineString);
				}
			}
			if (curChar != '\r' && curChar != '\n' && curChar != -1) {
				String appendStr =""+(char) curChar;
				sb.append(xmlEncode ? (XmlUtils.encodeChars(appendStr)):(appendStr));
			}
			prevChar = curChar;
		}
		return sb.toString();
	}

	public static String streamToString(InputStream stream, String endOfLineString, String streamEncoding, boolean xmlEncode)
		throws IOException {
		return readerToString(new InputStreamReader(stream,streamEncoding), endOfLineString, xmlEncode);
	}


	public static String streamToString(InputStream stream, String endOfLineString, boolean xmlEncode)
		throws IOException {
		return streamToString(stream,endOfLineString, DEFAULT_INPUT_STREAM_ENCODING, xmlEncode);
	}

	public static String resourceToString(URL resource, String endOfLineString, boolean xmlEncode) throws IOException {
		InputStream stream = resource.openStream();
		try {
			return streamToString(stream, endOfLineString, xmlEncode);
		}
		finally {
			stream.close();
		}
	}

	public static String resourceToString(URL resource) throws IOException {
		return resourceToString(resource, null, false);
	}
	
	public static String resourceToString(URL resource, String endOfLineString) throws IOException {
		return resourceToString(resource, endOfLineString, false);
	}

	public static void stringToFile(String string, String fileName) throws IOException {
		FileWriter fw = new FileWriter(fileName);
		try {
			fw.write(string);
		}
		finally {
			fw.close();
		}
	}

	/**
	 * String replacer.
	 * 
	 * @param target	is the original string
	 * @param from		is the string to be replaced
	 * @param to		is the string which will used to replace
	 * @return
	 */
	public static String replace (String source, String from, String to) {   
		int start = source.indexOf(from);
		if (start==-1) { 
			return source;
		} 
		int fromLength = from.length();
		char [] sourceArray = source.toCharArray();
		
		StringBuffer buffer = new StringBuffer();
		int srcPos=0;
		
		while (start != -1) {
			buffer.append (sourceArray, srcPos, start-srcPos);
			buffer.append (to);
			srcPos=start+fromLength;
			start = source.indexOf (from, srcPos);
		}
		buffer.append (sourceArray, srcPos, sourceArray.length-srcPos);
		return buffer.toString();
	 }

}
