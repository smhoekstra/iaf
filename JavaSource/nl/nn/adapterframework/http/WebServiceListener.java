/*
   Copyright 2013 Nationale-Nederlanden

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
package nl.nn.adapterframework.http;

import java.io.Serializable;
import java.util.Map;

import nl.nn.adapterframework.configuration.ConfigurationException;
import nl.nn.adapterframework.configuration.ConfigurationWarnings;
import nl.nn.adapterframework.core.HasPhysicalDestination;
//import nl.nn.adapterframework.core.IPushingListener;
import nl.nn.adapterframework.core.ListenerException;
import nl.nn.adapterframework.receivers.ServiceDispatcher;
import nl.nn.adapterframework.soap.SoapWrapper;
import nl.nn.adapterframework.util.ClassUtils;

import org.apache.commons.lang.StringUtils;

/**
 * Implementation of a {@link IPushingListener} that enables a {@link nl.nn.adapterframework.receivers.GenericReceiver}
 * to receive messages as a web-service.
 * <p><b>Configuration:</b>
 * <table border="1">
 * <tr><th>attributes</th><th>description</th><th>default</th></tr>
 * <tr><td>className</td><td>nl.nn.adapterframework.http.WebServiceListener</td><td>&nbsp;</td></tr>
 * <tr><td>{@link #setName(String) name}</td><td>name of the listener as known to the adapter</td><td>&nbsp;</td></tr>
 * <tr><td>{@link #setSoap(boolean) soap}</td><td>when <code>true</code>, messages sent are put in a SOAP envelope</td><td><code>true</code></td></tr>
 * <tr><td>{@link #setServiceNamespaceURI(String) serviceNamespaceURI}</td><td>namespace of the service that is provided by the adapter of this listener</td><td>&nbsp;</td></tr>
 * <tr><td>{@link #setApplicationFaultsAsSoapFaults(boolean) applicationFaultsAsSoapFaults}</td><td>Controls the behavior when an application-fault occurrs: 
 *   <table>
 *     <tr><td><code>true</code></td><td>errors are returned as a SOAP-fault</td></tr>
 *     <tr><td><code>false</code></td><td>errors are returned in error message generated by the IBIS error message formatter</td></tr>
 *   </table>
 * </td><td>true</td></tr>
 * </table>
 * @author  Gerrit van Brakel 
 * @version $Id$
 */
public class WebServiceListener extends PushingListenerAdapter implements Serializable, HasPhysicalDestination {

	private boolean soap = true;
	private String serviceNamespaceURI;
	private boolean nag=false; // controls warning about deprecated call via ServiceDispatcher_ServiceProxy 
	private SoapWrapper soapWrapper=null;

	/**
	 * initialize listener and register <code>this</code> to the JNDI
	 */
	public void configure() throws ConfigurationException {
		super.configure();
		if (isSoap()) {
			//ConfigurationWarnings configWarnings = ConfigurationWarnings.getInstance();
			//String msg = ClassUtils.nameOf(this) +"["+getName()+"]: the use of attribute soap=true has been deprecated. Please change to SoapWrapperPipe";
			//configWarnings.add(log, msg);
			soapWrapper=SoapWrapper.getInstance();
		}
		try {
			if (StringUtils.isNotEmpty(getServiceNamespaceURI())) {
				log.debug("registering listener ["+getName()+"] with ServiceDispatcher by serviceNamespaceURI ["+getServiceNamespaceURI()+"]");
				ServiceDispatcher.getInstance().registerServiceClient(getServiceNamespaceURI(), this);
			} else {
				log.debug("registering listener ["+getName()+"] with ServiceDispatcher");
				ServiceDispatcher.getInstance().registerServiceClient(getName(), this);
				if (nag) { 
					ConfigurationWarnings configWarnings = ConfigurationWarnings.getInstance();
					String msg = ClassUtils.nameOf(this) +"["+getName()+"]: calling webservices via de ServiceDispatcher_ServiceProxy is deprecated. Please specify a serviceNamespaceURI and modify the call accordingly";
					configWarnings.add(log, msg);
				}
			}
		} catch (Exception e){
			throw new ConfigurationException(e);
		}
	}

	public String processRequest(String correlationId, String message, Map requestContext) throws ListenerException {
		if (isSoap()) {
			try {
				String request = soapWrapper.getBody(message);
				String result = super.processRequest(correlationId, request, requestContext);
				String reply = soapWrapper.putInEnvelope(result,null);
				return reply;
			} catch (Exception e) {
				throw new ListenerException(e);
			}
		} else {
			return super.processRequest(correlationId, message, requestContext);
		}
	}

	public String getPhysicalDestinationName() {
		if (StringUtils.isNotEmpty(getServiceNamespaceURI())) {
			return "serviceNamespaceURI ["+getServiceNamespaceURI()+"]";
		} 		return "name ["+getName()+"]";
	}

	public void setSoap(boolean b) {
		soap = b;
	}
	public boolean isSoap() {
		return soap;
	}

	public String getServiceNamespaceURI() {
		return serviceNamespaceURI;
	}
	public void setServiceNamespaceURI(String string) {
		serviceNamespaceURI = string;
	}


	public boolean isApplicationFaultsAsSoapFaults() {
		return isApplicationFaultsAsExceptions();
	}
	public void setApplicationFaultsAsSoapFaults(boolean b) {
		setApplicationFaultsAsExceptions(b);
	}

}
