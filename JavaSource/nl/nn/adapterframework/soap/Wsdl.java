/*
 * $Log: Wsdl.java,v $
 * Revision 1.4  2012-03-30 17:03:45  m00f069
 * Michiel added JMS binding/service to WSDL generator, made WSDL validator work for Bis WSDL and made console show syntax problems for schema's used in XmlValidator
 *
 * Revision 1.3  2012/03/16 15:35:43  Jaco de Groot <jaco.de.groot@ibissource.org>
 * Michiel added EsbSoapValidator and WsdlXmlValidator, made WSDL's available for all adapters and did a bugfix on XML Validator where it seems to be dependent on the order of specified XSD's
 *
 * Revision 1.2  2011/12/15 10:08:06  Jaco de Groot <jaco.de.groot@ibissource.org>
 * Added CVS log
 *
 */
package nl.nn.adapterframework.soap;

import java.io.IOException;
import java.io.OutputStream;
import java.net.*;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.xml.XMLConstants;
import javax.xml.namespace.QName;
import javax.xml.stream.*;

import org.apache.log4j.Logger;

import nl.nn.adapterframework.configuration.IbisManager;
import nl.nn.adapterframework.core.*;
import nl.nn.adapterframework.http.WebServiceListener;
import nl.nn.adapterframework.jms.JmsListener;
import nl.nn.adapterframework.pipes.XmlValidator;
import nl.nn.adapterframework.util.*;


/**
 *  Utility class to generate the WSDL. Straight-forwardly implemented using stax only.
 *
 *  An object of this class represents the WSDL associated with one IBIS pipeline.
 *
 *
 *  TODO http://cxf.547215.n5.nabble.com/ClassName-quot-is-already-defined-in-quot-during-compilation-after-code-generation-td4299849.html
 *
 *  TODO perhaps use wsdl4j or easywsdl to generate the WSDL more genericly (for easy switching between 1.1 and 2.0).
 *
 * @author  Michiel Meeuwissen
 */
class Wsdl  {
     private static final Logger LOG = LogUtil.getLogger(Wsdl.class);

     private static final String WSDL      = "http://schemas.xmlsoap.org/wsdl/";
     private static final String SOAP_WSDL = "http://schemas.xmlsoap.org/wsdl/soap/";
     private static final String SOAP_HTTP = "http://schemas.xmlsoap.org/soap/http";


     private static final String SOAP_JMS  = "http://www.w3.org/2010/soapjms/";

     static final         String XSD       =  XMLConstants.W3C_XML_SCHEMA_NS_URI;//"http://www.w3.org/2001/XMLSchema";


     private final boolean indentWsdl;
     private final PipeLine pipeLine;
     private final String targetNamespace;
     private final String name;
     Set<XSD> xsds = null;

     private boolean recursiveXsds = false;
     private boolean includeXsds = false;

     private String documentation = "Generated by " + this.getClass().getName() + " on " + new Date();
     private boolean parsedXSDs = false;


     Wsdl(IbisManager ibisManager,
          String serviceName,
          boolean indent) {
         indentWsdl = indent;
         this.targetNamespace = serviceName;
         Adapter adapter = WsdlUtils.getAdapterByNamespaceUri(ibisManager, this.targetNamespace);
         if (adapter == null) {
             throw new IllegalArgumentException("No adapter with uri " + serviceName);
         }
         this.name     = adapter.getName();
         if (this.name == null) {
             throw new IllegalArgumentException("The adapter " + adapter + " has no name");
         }
         this.pipeLine = adapter.getPipeLine();
     }

     Wsdl(PipeLine pipeLine,
          boolean indent) {
         indentWsdl = indent;
         this.targetNamespace = WsdlUtils.getServiceNameSpaceURI(pipeLine.getAdapter());
         if (this.targetNamespace == null) {
             throw new IllegalStateException("No targetnamespace found in " + pipeLine.getAdapter());
         }
         this.pipeLine = pipeLine;
         this.name     = this.pipeLine.getAdapter().getName();
         if (this.name == null) {
             throw new IllegalArgumentException("The adapter " + pipeLine.getAdapter().getName() + " has no name");
         }

     }


     /**
      * Writes the WSDL to an output stream
      * @param out
      * @param servlet  The servlet what is used as the web service (because this needs to be present in the WSDL)
      * @throws XMLStreamException
      * @throws IOException
      */
     public void wsdl(OutputStream out, String servlet) throws XMLStreamException, IOException, URISyntaxException {
         XMLStreamWriter w = WsdlUtils.createWriter(out, indentWsdl);

         w.writeStartDocument(WsdlUtils.ENCODING, "1.0");
         w.setPrefix("wsdl", WSDL);
         w.setPrefix("xsd", XSD);
         w.setPrefix("soap", SOAP_WSDL);
         w.setPrefix("jms", SOAP_JMS);
         w.setPrefix("ibis", getWsdlTargetNamespace());
         for (XSD xsd : getXSDs()) {
             w.setPrefix(xsd.pref, xsd.nameSpace);
         }
         w.writeStartElement(WSDL, "definitions"); {
             w.writeNamespace("wsdl", WSDL);
             w.writeNamespace("xsd", XSD);
             w.writeNamespace("soap", SOAP_WSDL);
             w.writeNamespace("ibis", getWsdlTargetNamespace());
             for (XSD xsd : getXSDs()) {
                 w.writeNamespace(xsd.pref, xsd.nameSpace);
             }
             w.writeAttribute("targetNamespace", getWsdlTargetNamespace());

             documentation(w);
             types(w);
             messages(w);
             portType(w);
             binding(w);
             service(w, servlet);

         }
         w.writeEndDocument();
         w.close();
     }


     /**
      * Generates a zip file (and writes it to the given outputstream), containing the WSDL and all referenced XSD's.
      * @see {@link #wsdl(java.io.OutputStream, String)}
      */
     public void zip(OutputStream stream, String servletName) throws IOException, XMLStreamException, URISyntaxException {
         ZipOutputStream out = new ZipOutputStream(stream);

         // First an entry for the WSDL itself:
         ZipEntry wsdlEntry = new ZipEntry(getName() + ".wsdl");
         out.putNextEntry(wsdlEntry);
         wsdl(out, servletName);
         out.closeEntry();

         //And then all XSD's
         setRecursiveXsds(true);
         Set entries = new HashSet();
         Map<String, String> correctingNamespaces = new HashMap<String, String>();
         for (XSD xsd : getXSDs()) {
             String zipName = xsd.getBaseUrl() + xsd.getName();
             if (entries.add(zipName)) {
                 ZipEntry xsdEntry = new ZipEntry(zipName);
                 out.putNextEntry(xsdEntry);
                 XMLStreamWriter writer
                     = WsdlUtils.createWriter(out, false);
                 WsdlUtils.includeXSD(xsd, writer, correctingNamespaces, true);
                 out.closeEntry();
             } else {
                 LOG.warn("Duplicate xsds in " + this + " " + xsd + " " + getXSDs());
             }
         }
         out.close();
     }

     public String getName() {
         return name;
     }


     protected String getWsdlTargetNamespace() {
         if (targetNamespace.endsWith("/")) {
             return targetNamespace + "wsdl/";
         } else {
             return targetNamespace + "/wsdl/";
         }
     }


    private List<XSD> parseSchema(String schema) throws MalformedURLException, URISyntaxException {
         List<XSD> result = new ArrayList<XSD>();
         if (schema != null) {
             String[] split =  schema.split("\\s+");
             if (split.length % 2 != 0) throw new IllegalStateException("The schema must exist from an even number of strings, but it is " + schema);
             for (int i = 0; i < split.length; i += 2) {
                 result.add(getXSD(split[i], split[i + 1]));
             }
         }
         return result;
     }


     /**
      * Returns a map: namespace -> Collection of all relevant XSD's
      * @return
      * @throws XMLStreamException
      * @throws IOException
      */
     Map<String, Collection<XSD>> getMappedXSDs() throws XMLStreamException, IOException, URISyntaxException {
         Map<String, Collection<XSD>> result = new HashMap<String, Collection<XSD>>();
         for (XSD xsd : getXSDs()) {
             Collection<XSD> col = result.get(xsd.nameSpace);
             if (col == null) {
                 col = new ArrayList<XSD>();
                 result.put(xsd.nameSpace, col);
             }
             col.add(xsd);
         }
         return result;
     }
     Set<XSD> getXSDs() throws IOException, XMLStreamException, URISyntaxException {
         if (xsds == null) {
             xsds = new TreeSet<XSD>();
             {
                 XmlValidator inputValidator = (XmlValidator) pipeLine.getInputValidator();

                 if (inputValidator != null) {
                     String inputSchema = inputValidator.getSchema();
                     if (inputSchema != null) {
                         XSD x = getXSD(targetNamespace, inputSchema);
                         if (recursiveXsds) {
                             x.getImportXSDs(xsds);
                         }
                     }


                     for (XSD x : parseSchema(inputValidator.getSchemaLocation())) {
                         if (recursiveXsds) {
                             x.getImportXSDs(xsds);
                         }
                     }
                 }
             }
             {
                 XmlValidator outputValidator = (XmlValidator) pipeLine.getOutputValidator();
                 if (outputValidator != null) {
                     String outputSchema = outputValidator.getSchema();
                     if (outputSchema != null) {
                         getXSD(null, outputSchema);
                     }
                     parseSchema(outputValidator.getSchemaLocation());
                 }
             }
         }
         return xsds;
     }
     protected XSD getXSD(String nameSpace) throws IOException, XMLStreamException, URISyntaxException {
         if (nameSpace == null) throw new IllegalArgumentException("Cannot get an XSD for null namespace");
         for (XSD xsd : getXSDs()) {
             if (xsd.nameSpace.equals(nameSpace)) {
                 return xsd;
             }
         }
         throw new IllegalArgumentException("No xsd for namespace " + nameSpace + " found");
     }

     protected static final QName NAME           = new QName(null, "name");
     protected static final QName TNS            = new QName(null, "targetNamespace");
     protected static final QName ELFORMDEFAULT  = new QName(null, "elementFormDefault");
     protected static final QName SCHEMA         = new QName(XSD,  "schema");
     protected static final QName ELEMENT        = new QName(XSD,  "element");
     protected static final QName IMPORT         = new QName(XSD,  "import");
     protected static final QName INCLUDE        = new QName(XSD,  "include");
     protected static final QName SCHEMALOCATION = new QName(null, "schemaLocation");
     protected static final QName NAMESPACE      = new QName(null, "namespace");
     protected static final QName XMLNS          = new QName(null, XMLConstants.XMLNS_ATTRIBUTE);


     /**
      * Outputs a 'documentation' section of the WSDL
      */
     protected void documentation(XMLStreamWriter w) throws XMLStreamException {
         w.writeStartElement(WSDL, "documentation");
         w.writeCData(documentation);
         w.writeEndElement();
     }

     /**
      * Output the 'types' section of the WSDL
      * @param w
      * @throws XMLStreamException
      * @throws IOException
      */
     protected void types(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {
         w.writeStartElement(WSDL, "types");
         Map<String, String> correctingNamesSpaces = new HashMap<String, String>();
         if (includeXsds) {
             for (XSD xsd : getXSDs()) {
                 WsdlUtils.includeXSD(xsd, w, correctingNamesSpaces, false);
             }
         }  else {
             for (Map.Entry<String, Collection<XSD>> xsd: getMappedXSDs().entrySet()) {
                 WsdlUtils.xsincludeXSDs(xsd.getKey(), xsd.getValue(), w, correctingNamesSpaces);
             }
         }
         parsedXSDs = true;
         w.writeEndElement();
    }


     /**
      * Outputs the 'messages' section.
      * @param w
      * @throws XMLStreamException
      * @throws IOException
      */
     protected void messages(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {
         message(w, "Header", getHeaderTags(), null);
         message(w, "PipeLineInput", getInputTags(), targetNamespace);
         XmlValidator outputValidator = (XmlValidator) pipeLine.getOutputValidator();
         if (outputValidator == null) {
             LOG.debug("The PipeLine " + pipeLine + " has no output validator, this is a oneway wsdl");
         } else {
             Collection<QName> out = getOutputTags();
             message(w, "PipeLineOutput", out, null);//out.xsd.nameSpace);
         }
         //message(w, "PipeLineFault", "error", "bla:bloe");

     }

     protected void message(XMLStreamWriter w, String name, Collection<QName> tags, String nameSpace) throws XMLStreamException, IOException {
         if (tags == null) throw new IllegalArgumentException("Tag cannot be null for " + nameSpace + " " + name);

         if (!tags.isEmpty()) {
             w.writeStartElement(WSDL, "message");
             w.writeAttribute("name", name);
             {
                 for (QName tag : tags) {
                     w.writeEmptyElement(WSDL, "part");
                     w.writeAttribute("name", getIbisName(tag));
                     String typ = tag.getPrefix() + ":" + tag.getLocalPart();
                     w.writeAttribute("element", typ);
                 }
             }
             w.writeEndElement();
         }

     }
     protected void portType(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {
         w.writeStartElement(WSDL, "portType");
         w.writeAttribute("name", "PipeLine"); {
             w.writeStartElement(WSDL, "operation");
             w.writeAttribute("name", "Process"); {
                 w.writeEmptyElement(WSDL, "input");
                 w.writeAttribute("message", "ibis:PipeLineInput");

                 if (getOutputTags() != null) {
                     w.writeEmptyElement(WSDL, "output");
                     w.writeAttribute("message", "ibis:PipeLineOutput");
                 }
                 /*
                w.writeEmptyElement(WSDL, "fault");
                w.writeAttribute("message", "ibis:PipeLineFault");
                */

             }
             w.writeEndElement();
         }
         w.writeEndElement();
     }


     protected String getSoapAction() {
         AppConstants appConstants = AppConstants.getInstance();
         String sa = appConstants.getProperty("wsdl." + getName() + ".soapAction");
         if (sa != null) return sa;
         sa = appConstants.getProperty("wsdl.soapAction");
         if (sa != null) return sa;
         return "${wsdl.soapAction}";
     }

     protected void binding(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {
         for (IListener listener : WsdlUtils.getListeners(pipeLine.getAdapter())) {
             if (listener instanceof WebServiceListener) {
                 httpBinding(w);
             } else if (listener instanceof JmsListener) {
                 jmsBinding(w, (JmsListener) listener);
             } else {
                 w.writeComment("Binding: Unrecognized listener " + listener.getClass() + ": " + listener.getName());
             }
         }
     }

     protected void httpBinding(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {
         w.writeStartElement(WSDL, "binding");
         w.writeAttribute("name", "SoapBinding");
         w.writeAttribute("type", "ibis:PipeLine"); {
             w.writeEmptyElement(SOAP_WSDL, "binding");
             w.writeAttribute("transport", SOAP_HTTP);
             w.writeAttribute("style", "document");
             writeSoapOperation(w);
         }
         w.writeEndElement();
     }

    protected void writeSoapOperation(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {

        w.writeStartElement(WSDL, "operation");
        w.writeAttribute("name", "Process"); {

            w.writeEmptyElement(SOAP_WSDL, "operation");
            w.writeAttribute("style", "document");
            w.writeAttribute("soapAction", getSoapAction());


            w.writeStartElement(WSDL, "input"); {
                writeSoapHeader(w);
                Collection<QName>  inputTags = getInputTags();
                //w.writeEmptyElement(input.xsd.nameSpace, input.getRootTag());
                w.writeEmptyElement(SOAP_WSDL, "body");
                writeParts(w, inputTags);
                w.writeAttribute("use", "literal");
            }
            w.writeEndElement();

            Collection<QName> outputTags = getOutputTags();
            if (outputTags != null) {
                w.writeStartElement(WSDL, "output"); {
                    writeSoapHeader(w);
                    ///w.writeEmptyElement(outputTag.xsd.nameSpace, outputTag.getRootTag());
                    w.writeEmptyElement(SOAP_WSDL, "body");
                    writeParts(w, outputTags);
                    w.writeAttribute("use", "literal");
                }
                w.writeEndElement();
            }

            /*
            w.writeStartElement(WSDL, "fault"); {
                w.writeEmptyElement(SOAP_WSDL, "error");
                w.writeAttribute("use", "literal");
            }
            w.writeEndElement();
            */
        }
        w.writeEndElement();
    }

     protected void writeSoapHeader(XMLStreamWriter w) throws XMLStreamException, IOException, URISyntaxException {
         Collection<QName>  headers = getHeaderTags();
         if (! headers.isEmpty()) {
             if (headers.size() > 1) {
                 LOG.warn("Can only deal with one soap header. Taking only the first of " + headers);
             }
             w.writeEmptyElement(SOAP_WSDL, "header");
             w.writeAttribute("part", getIbisName(headers.iterator().next()));
             w.writeAttribute("use",     "literal");
             w.writeAttribute("message", "ibis:Header");
         }
     }

     protected void writeParts(XMLStreamWriter w, Collection<QName> tags) throws XMLStreamException {
         StringBuilder builder = new StringBuilder();
         for (QName outputTag : tags) {
             if (builder.length() > 0) builder.append(" ");
             builder.append(getIbisName(outputTag));
         }
         w.writeAttribute("parts", builder.toString());
     }

     protected String getIbisName(QName qname) {
         return qname.getLocalPart();
     }

     protected void jmsBinding(XMLStreamWriter w, JmsListener listener) throws XMLStreamException, IOException, URISyntaxException {
         w.writeStartElement(WSDL, "binding");
         w.writeAttribute("name", "SoapBinding");
         w.writeAttribute("type", "ibis:PipeLine"); {
             w.writeEmptyElement(SOAP_WSDL, "binding");
             w.writeAttribute("style", "document");
             w.writeAttribute("transport", SOAP_JMS);
             w.writeEmptyElement(SOAP_JMS, "binding");
             w.writeAttribute("messageFormat", "Text");
             writeSoapOperation(w);
         }
         w.writeEndElement();
     }

     protected void service(XMLStreamWriter w, String servlet) throws XMLStreamException {
         for (IListener listener : WsdlUtils.getListeners(pipeLine.getAdapter())) {
             if (listener instanceof WebServiceListener) {
                 httpService(w, servlet);
             } else if (listener instanceof JmsListener) {
                 jmsService(w, (JmsListener) listener);
             } else {
                 w.writeComment("Service: Unrecognized listener " + listener.getClass() + " " + listener);
             }
         }
     }

     protected void httpService(XMLStreamWriter w, String servlet) throws XMLStreamException {
         w.writeStartElement(WSDL, "service");
         w.writeAttribute("name", getName()); {
             w.writeStartElement(WSDL, "port");
             w.writeAttribute("name", "SoapHttp");
             w.writeAttribute("binding", "ibis:SoapBinding"); {
                 w.writeEmptyElement(SOAP_WSDL, "address");
                 w.writeAttribute("location", servlet);

             }
             w.writeEndElement();
         }
         w.writeEndElement();
     }


     protected void jmsService(XMLStreamWriter w, JmsListener listener) throws XMLStreamException {
         w.writeStartElement(WSDL, "service");
         w.writeAttribute("name", getName()); {
             w.writeStartElement(WSDL, "port");
             w.writeAttribute("name", "SoapJMS");
             w.writeAttribute("binding", "ibis:SoapBinding"); {
                 w.writeEmptyElement(SOAP_WSDL, "address");
                 w.writeAttribute("location", listener.getDestinationName());
                 w.writeStartElement(SOAP_JMS, "connectionFactory"); {
                     w.writeCharacters("QueueConnectionFactory");
                 }
                 w.writeEndElement();
                 w.writeStartElement(SOAP_JMS, "targetAddress");
                 w.writeAttribute("destination", listener.getDestinationType()); {
                     w.writeCharacters("TS." + getName());
                 }
                 w.writeEndElement();
             }
             w.writeEndElement();
         }
         w.writeEndElement();
     }

     protected PipeLine getPipeLine() {
         return pipeLine;
     }

     protected Collection<QName> getHeaderTags(XmlValidator xmlValidator) throws XMLStreamException, IOException, URISyntaxException {
         if (xmlValidator instanceof SoapValidator) {
             return withPrefixes(((SoapValidator) xmlValidator).getSoapHeaderTags());
         } else {
             return Collections.emptyList();
         }
     }
     protected Collection<QName> getRootTags(XmlValidator xmlValidator, String defaultNamespace) throws IOException, XMLStreamException, URISyntaxException {
         if (xmlValidator == null) {
             throw new IllegalStateException("The adapter " + pipeLine + " has no validator");
         }
         if (xmlValidator instanceof SoapValidator) {
             SoapValidator validator = (SoapValidator) xmlValidator;
             return withPrefixes(validator.getSoapBodyTags());
         } else {
             if (defaultNamespace == null) {
                 List<XSD> xsds = parseSchema(xmlValidator.getSchemaLocation());
                 if (xsds.isEmpty()) {
                     return Collections.emptyList();
                 } else {
                     return Collections.singletonList(xsds.get(0).getTag(xmlValidator.getRoot()));
                 }
             } else {
                 XSD xsd = getXSD(defaultNamespace);
                 return Collections.singletonList(xsd.getTag(xmlValidator.getRoot()));
             }
         }
     }
     protected Collection<QName> withPrefixes(Collection<QName> qnames) throws XMLStreamException, IOException, URISyntaxException {
         List<QName> result = new ArrayList<QName>();
         // we need the QName with the correct prefix
         for (QName qname : qnames) {
             result.add(getXSD(qname.getNamespaceURI()).getTag(qname.getLocalPart()));
         }
         return result;
     }


     protected Collection<QName> getHeaderTags() throws IOException, XMLStreamException, URISyntaxException {
         return getHeaderTags((XmlValidator) getPipeLine().getInputValidator());
     }

     protected Collection<QName> getInputTags() throws IOException, XMLStreamException, URISyntaxException {
         return getRootTags((XmlValidator) getPipeLine().getInputValidator(), targetNamespace);
     }

     protected Collection<QName> getOutputTags() throws IOException, XMLStreamException, URISyntaxException {
         XmlValidator outputValidator = (XmlValidator) getPipeLine().getOutputValidator();
         if (outputValidator != null) {
             return getRootTags((XmlValidator) getPipeLine().getOutputValidator(), null);
         } else {
             LOG.debug("Oneway");
             return null;
         }
     }



    private XSD getXSD(String ns, String resource) throws URISyntaxException {
         URI url = ClassUtils.getResourceURL(resource).toURI();
         if (url == null) {
             throw new IllegalArgumentException("No such resource " + resource);
         }
         for (XSD xsd : xsds) {

             if (xsd.nameSpace == null) {
                 if (xsd.url.equals(url)) {
                     return xsd;
                 }
             } else  {
                 if (xsd.nameSpace.equals(ns) && xsd.url.equals(url)){

                     return xsd;
                 }
             }
         }
         XSD xsd = new XSD("", ns, url, xsds.size() + 1);
         xsds.add(xsd);
         return  xsd;
     }

     public boolean isRecursiveXsds() {
         return recursiveXsds;
     }

     /**
      * Make an effort to collect all XSD's also the included ones in {@link #getXSDs()}
      * @param recursiveXsds
      */
     public void setRecursiveXsds(boolean recursiveXsds) {
         this.recursiveXsds = recursiveXsds;
         xsds = null;
     }

     public String getDocumentation() {
         return documentation;
     }

     public void setDocumentation(String documentation) {
         this.documentation = documentation;
     }

     public boolean isIncludeXsds() {
         return includeXsds;
     }

     public void setIncludeXsds(boolean includeXsds) {
         this.includeXsds = includeXsds;
     }


    /*
        public void easywsdl(OutputStream out, String servlet) throws XMLStreamException, IOException, SchemaException, URISyntaxException {
            Description description = WSDLFactory.newInstance().newDescription(AbsItfDescription.WSDLVersionConstants.WSDL11);

            SchemaFactory fact = SchemaFactory.newInstance();
            Types t = description.getTypes();
            for (XSD xsd : getXsds()) {
                description.addNamespace(xsd.pref, xsd.nameSpace);
                SchemaReader sr = fact.newSchemaReader();
                Schema s = sr.read(xsd.url);
                t.addSchema(s);
            }
            InterfaceType it = description.createInterface();
            Operation o = it.createOperation();
            Input i = o.createInput();
            i.setName("IbisInput");
            //i.
            // s
            t.addOperation(it.createOperation());
            description.addInterface();
            Binding binding = description.createBinding();
            BindingOperation op = binding.createBindingOperation();
            //description.addBinding(binding);
        }
    */
}
