/*
 * $Log: Wsdl.java,v $
 * Revision 1.2  2011-12-15 10:08:06  m00f069
 * Added CVS log
 *
 */
package nl.nn.adapterframework.soap;

import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.UnsupportedEncodingException;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLDecoder;
import java.util.*;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

import javax.xml.XMLConstants;
import javax.xml.namespace.QName;
import javax.xml.stream.*;
import javax.xml.stream.events.Attribute;
import javax.xml.stream.events.StartElement;
import javax.xml.stream.events.XMLEvent;

import org.apache.log4j.Logger;

import nl.nn.adapterframework.configuration.Configuration;
import nl.nn.adapterframework.configuration.IbisManager;
import nl.nn.adapterframework.core.Adapter;
import nl.nn.adapterframework.core.IAdapter;
import nl.nn.adapterframework.core.IListener;
import nl.nn.adapterframework.core.PipeLine;
import nl.nn.adapterframework.http.WebServiceListener;
import nl.nn.adapterframework.pipes.XmlValidator;
import nl.nn.adapterframework.receivers.ReceiverBase;
import nl.nn.adapterframework.util.AppConstants;
import nl.nn.adapterframework.util.ClassUtils;
import nl.nn.adapterframework.util.LogUtil;

import javanet.staxutils.IndentingXMLStreamWriter;
import javanet.staxutils.XMLStreamEventWriter;
import javanet.staxutils.XMLStreamUtils;
import javanet.staxutils.events.AttributeEvent;
import javanet.staxutils.events.StartElementEvent;
import javanet.staxutils.helpers.StreamWriterDelegate;


/**
 *  Utility class to generate the WSDL. Straight-forwardly implemented using stax only.
 *
 *
 *  TODO http://cxf.547215.n5.nabble.com/ClassName-quot-is-already-defined-in-quot-during-compilation-after-code-generation-td4299849.html
 *
 *  TODO perhaps use wsdl4j or easywsdl to generate the WSDL more genericly (for easy switching between 1.1 and 2.0).
 *
 * @version Id
 * @author  Michiel Meeuwissen
 */
class Wsdl  {
     private static final Logger LOG = LogUtil.getLogger(Wsdl.class);

     private static final String WSDL      = "http://schemas.xmlsoap.org/wsdl/";
     private static final String SOAP_WSDL = "http://schemas.xmlsoap.org/wsdl/soap/";
     private static final String SOAP_HTTP = "http://schemas.xmlsoap.org/soap/http";
     static final String XSD               =  "http://www.w3.org/2001/XMLSchema"; //XMLConstants.W3C_XML_SCHEMA_NS_URI;

     private static final String ENCODING  = "UTF-8";

     private static final XMLInputFactory INPUT_FACTORY   = XMLInputFactory.newInstance();
     private static final XMLEventFactory EVENT_FACTORY   = XMLEventFactory.newInstance();
     private static final XMLOutputFactory OUTPUT_FACTORY = XMLOutputFactory.newInstance();

     static {
         INPUT_FACTORY.setProperty(XMLInputFactory.IS_NAMESPACE_AWARE,        Boolean.valueOf(true));
         OUTPUT_FACTORY.setProperty(XMLOutputFactory.IS_REPAIRING_NAMESPACES, Boolean.valueOf(true));
     }


     private final boolean indentWsdl;
     private final PipeLine pipeLine;
     private final String targetNamespace;
     private final String name;
     Set/*<XSD>*/ xsds = null;

     private boolean recursiveXsds = false;
     private boolean includeXsds = false;

     private String documentation = "Generated by " + this.getClass().getName() + " on " + new Date();
     private boolean parsedXSDs = false;


     Wsdl(IbisManager ibisManager,
          String serviceName,
          boolean indent) {
         indentWsdl = indent;
         this.targetNamespace = serviceName;
         Adapter adapter = getAdapterByNamespaceUri(ibisManager, this.targetNamespace);
         if (adapter == null) {
             throw new IllegalArgumentException("No adapter with uri " + serviceName);
         }
         this.name     = adapter.getName();
         if (this.name == null) {
             throw new IllegalArgumentException("The adapter " + adapter + " has no name");
         }
         this.pipeLine = adapter.getPipeLine();
     }

     Wsdl(PipeLine pipeLine,
          boolean indent) {
         indentWsdl = indent;
         this.targetNamespace = getServerNameSpace(pipeLine.getAdapter());
         if (this.targetNamespace == null) {
             throw new IllegalStateException("No targetnamespace found in " + pipeLine.getAdapter());
         }
         this.pipeLine = pipeLine;
         this.name     = pipeLine.getAdapter().getName();
         if (this.name == null) {
             throw new IllegalArgumentException("The adapter " + pipeLine.getAdapter().getName() + " has no name");
         }
         if (pipeLine== null) {
             throw new IllegalArgumentException("No adapter with uri " + this.targetNamespace);
         }
     }


     public void wsdl(OutputStream out, String servlet) throws XMLStreamException, IOException {
         XMLStreamWriter w = createWriter(out);

         w.writeStartDocument(ENCODING, "1.0");
         w.setPrefix("wsdl", WSDL);
         w.setPrefix("xsd", XSD);
         w.setPrefix("soap", SOAP_WSDL);
         w.setPrefix("ibis", getWsdlTargetNamespace());
         for (Iterator iterator = getXSDs().iterator(); iterator.hasNext(); ) {
             XSD xsd = (XSD) iterator.next();
             w.setPrefix(xsd.pref, xsd.nameSpace);
         }
         w.writeStartElement(WSDL, "definitions"); {
             w.writeNamespace("wsdl", WSDL);
             w.writeNamespace("xsd", XSD);
             w.writeNamespace("soap", SOAP_WSDL);
             w.writeNamespace("ibis", getWsdlTargetNamespace());
             for (Iterator iterator = getXSDs().iterator(); iterator.hasNext(); ) {
                 XSD xsd = (XSD) iterator.next();
                 w.writeNamespace(xsd.pref, xsd.nameSpace);
             }
             w.writeAttribute("targetNamespace", getWsdlTargetNamespace());

             documentation(w);
             types(w);
             messages(w);
             portType(w);
             binding(w);
             service(w, servlet);

         }
         w.writeEndDocument();
         w.close();
     }

     public String getName() {
         return name;

     }
     public void zip(OutputStream stream, String servletName) throws IOException, XMLStreamException {

         ZipOutputStream out = new ZipOutputStream(stream);
         ZipEntry wsdlEntry = new ZipEntry(getName() + ".wsdl");
         out.putNextEntry(wsdlEntry);
         wsdl(out, servletName);
         out.closeEntry();
         setRecursiveXsds(true);
         Set entries = new HashSet();
         Map correctingNamespaces = new HashMap();
         for (Iterator iterator = getXSDs().iterator(); iterator.hasNext(); ) {
             Wsdl.XSD xsd = (Wsdl.XSD) iterator.next();
             String zipName = xsd.getBaseUrl() + xsd.getName();
             if (entries.add(zipName)) {
                 ZipEntry xsdEntry = new ZipEntry(zipName);
                 out.putNextEntry(xsdEntry);
                 XMLStreamWriter writer
                     = Wsdl.createWriter(out, false);
                 Wsdl.includeXSD(xsd, writer, correctingNamespaces, true);
                 out.closeEntry();
             } else {
                 LOG.warn("Duplicate xsds in " + this + " " + xsd + " " + getXSDs());
             }
         }
         out.close();
     }

     protected void documentation(XMLStreamWriter w) throws XMLStreamException {
         w.writeStartElement(WSDL, "documentation");
         w.writeCData(documentation);
         w.writeEndElement();
     }

     protected String getWsdlTargetNamespace() {
         if (targetNamespace.endsWith("/")) {
             return targetNamespace + "wsdl/";
         } else {
             return targetNamespace + "/wsdl/";
         }
     }

     static Adapter getAdapterByNamespaceUri(IbisManager ibisManager, String targetNamespace) {
         Configuration configuration = ibisManager.getConfiguration();
         Iterator i = configuration.getRegisteredAdapters().iterator();
         while (i.hasNext()) {
             IAdapter a = (IAdapter) i.next();
             Iterator j = a.getReceiverIterator();
             while (j.hasNext()) {
                Object o = j.next();
                 if (o instanceof ReceiverBase) {
                     ReceiverBase r = (ReceiverBase) o;
                     IListener l = r.getListener();
                     if (l instanceof WebServiceListener) {
                         WebServiceListener wsl = (WebServiceListener) l;
                         if (wsl.getServiceNamespaceURI().equals(targetNamespace)) {
                             return (Adapter) a;
                         }
                     }
                 }
             }
         }
         throw new IllegalStateException("No adapter found for " + targetNamespace);
     }

     String getServerNameSpace(IAdapter a) {
         Iterator j = a.getReceiverIterator();
         while (j.hasNext()) {
             Object o = j.next();
             if (o instanceof ReceiverBase) {
                 ReceiverBase r = (ReceiverBase) o;
                 IListener l = r.getListener();
                 if (l instanceof WebServiceListener) {
                     WebServiceListener wsl = (WebServiceListener) l;
                     return wsl.getServiceNamespaceURI();
                 }
             }
         }
         return null;
     }


     private List parseSchema(String schema) throws MalformedURLException {
         List result = new ArrayList();
         if (schema != null) {
             String[] split =  schema.split("\\s+");
             if (split.length % 2 != 0) throw new IllegalStateException("The schema must exist from an even number of string, but it is " + schema);
             for (int i = 0; i < split.length; i+=2) {
                 result.add(getXSD(split[i], split[i + 1]));
             }
         }
         return result;
     }



     Set getXSDs() throws IOException, XMLStreamException {
         if (xsds == null) {
             xsds = new TreeSet();
             {
                 XmlValidator inputValidator = (XmlValidator) pipeLine.getInputValidator();

                 String inputSchema = inputValidator.getSchema();
                 if (inputSchema != null) {
                     XSD x = getXSD(targetNamespace, inputSchema);
                     if (recursiveXsds) {
                         x.getImportXSDs(xsds);
                     }
                 }

                 if (inputValidator != null) {
                     for (Iterator i = parseSchema(inputValidator.getSchemaLocation()).iterator(); i.hasNext();) {
                         XSD x = (XSD) i.next();
                         if (recursiveXsds) {
                             x.getImportXSDs(xsds);
                         }
                     }
                 }
             }
             {
                 XmlValidator outputValidator = (XmlValidator) pipeLine.getOutputValidator();
                 if (outputValidator != null) {
                     String outputSchema = outputValidator.getSchema();
                     if (outputSchema != null) {
                         getXSD(null, outputSchema);
                     }
                     parseSchema(outputValidator.getSchemaLocation());
                 }
             }
         }
         return xsds;
     }
     protected XSD getXSD(String nameSpace) throws IOException, XMLStreamException {
         for (Iterator iterator = getXSDs().iterator(); iterator.hasNext(); ) {
             XSD xsd = (XSD) iterator.next();
             if (xsd.nameSpace.equals(nameSpace)) {
                 return xsd;
             }
         }
         throw new IllegalArgumentException("No xsd for namespace " + nameSpace + " found");
     }

     protected static final QName NAME = new QName(null, "name");
     protected static final QName TNS = new QName(null, "targetNamespace");
     protected static final QName ELFORMDEFAULT = new QName(null, "elementFormDefault");
     protected static final QName SCHEMA  = new QName(XSD, "schema");
     protected static final QName ELEMENT = new QName(XSD, "element");
     protected static final QName IMPORT = new QName(XSD, "import");
     protected static final QName INCLUDE = new QName(XSD, "include");
     protected static final QName SCHEMALOCATION = new QName(null, "schemaLocation");
     protected static final QName NAMESPACE = new QName(null, "namespace");
     protected static final QName XMLNS    = new QName(null, XMLConstants.XMLNS_ATTRIBUTE);


     protected void types(XMLStreamWriter w) throws XMLStreamException, IOException {
         w.writeStartElement(WSDL, "types");
         Map correctingNamesSpaces = new HashMap();
         for (Iterator iterator = getXSDs().iterator(); iterator.hasNext(); ) {
             XSD xsd = (XSD) iterator.next();
             if (includeXsds) {
                 includeXSD(xsd, w, correctingNamesSpaces, false);
             } else {
                 xsincludeXSDs(xsd, w, correctingNamesSpaces);
             }
         }
         parsedXSDs = true;
         w.writeEndElement();
    }

     static void xsincludeXSDs(final XSD xsd, final XMLStreamWriter w, final Map correctingNameSpaces) throws IOException, XMLStreamException {
         w.writeStartElement(XSD, "schema");
         w.writeAttribute("targetNamespace", xsd.nameSpace); {
             w.writeEmptyElement(XSD, "include");
             w.writeAttribute("schemaLocation", xsd.getBaseUrl() + xsd.getName());
         }
         w.writeEndElement();
         // includeing the XSD will also parse it, e.g. to determin the first tag
         includeXSD(xsd, OUTPUT_FACTORY.createXMLStreamWriter(new OutputStream() {
             public void write(int i) throws IOException {
                 // /dev/null
             }
         }, ENCODING), correctingNameSpaces, true);
     }


     static void includeXSD(final XSD xsd, XMLStreamWriter xmlStreamWriter, Map correctingNamespaces, final boolean standalone) throws IOException, XMLStreamException {
         final XMLStreamEventWriter streamEventWriter = new XMLStreamEventWriter(new NamespaceCorrectingXMLStreamWriter(xmlStreamWriter, correctingNamespaces));
         InputStream in = xsd.url.openStream();

         String xsdNamespace = xsd.nameSpace;
         {
             String correct = (String) correctingNamespaces.get(xsdNamespace);
             if (correct != null) {
                 xsdNamespace = correct;
             }
         }
         if (in == null) throw new IllegalStateException("" + xsd + " not found");
         XMLEventReader er = INPUT_FACTORY.createXMLEventReader(in, ENCODING);
         String wrongNamespace = null;
         while (er.hasNext()) {
             XMLEvent e = er.nextEvent();
             switch (e.getEventType()) {
             case XMLStreamConstants.START_DOCUMENT:
             case XMLStreamConstants.END_DOCUMENT:
                 if (standalone) break;
             case XMLStreamConstants.COMMENT:
                 break;
             case XMLStreamConstants.START_ELEMENT:
                 StartElement el = e.asStartElement();
                 if (el.getName().equals(SCHEMA)) {
                     if (xsdNamespace == null) {
                         xsdNamespace = el.getAttributeByName(TNS).getValue();
                         String correct = (String) correctingNamespaces.get(xsdNamespace);
                         if (correct != null) {
                             xsdNamespace = correct;
                         }
                     }
                     if (xsdNamespace != null) {
                         StartElement ne =
                             XMLStreamUtils.mergeAttributes(el,
                                 Collections.singletonList(new AttributeEvent(TNS, xsdNamespace)).iterator(), EVENT_FACTORY);
                         if (!ne.equals(e)) {
                             List list = new ArrayList();
                             list.add(new AttributeEvent(ELFORMDEFAULT, "qualified"));
                             list.add(new AttributeEvent(XMLNS, xsdNamespace));
                             Attribute targetNameSpace = el.getAttributeByName(TNS);
                             e = XMLStreamUtils.mergeAttributes(ne,	list.iterator(), EVENT_FACTORY);
                             if (targetNameSpace != null) {
                                 String currentTarget = targetNameSpace.getValue();
                                 if (! currentTarget.equals(xsdNamespace)) {
                                     wrongNamespace = currentTarget;
                                     if (!correctingNamespaces.containsKey(wrongNamespace)) {
                                         correctingNamespaces.put(wrongNamespace, xsdNamespace);
                                         LOG.warn(xsd.url + " Corrected " + el + " -> " + e);
                                     }
                                 }

                             }
                         }
                     }
                 } else if (el.getName().equals(IMPORT)) {
                     Attribute schemaLocation = el.getAttributeByName(SCHEMALOCATION);
                     if (schemaLocation != null) {
                         String location = schemaLocation.getValue();
                         String relativeTo = xsd.parentLocation;
                         if (relativeTo.length() > 0 && location.startsWith(relativeTo)) {
                             location = location.substring(relativeTo.length());
                         }
                         e =
                             XMLStreamUtils.mergeAttributes(el,
                                 Collections.singletonList(new AttributeEvent(SCHEMALOCATION, location)).iterator(), EVENT_FACTORY);
                         if (LOG.isDebugEnabled()) {
                             LOG.debug(xsd.url + " Corrected " + el + " -> " + e);
                             LOG.debug(xsd.url + " Relative to : " + relativeTo + " -> " + e);
                         }
                     }
                 } else if (el.getName().equals(ELEMENT)) {
                     if (xsd.firstTag == null) {
                         xsd.firstTag = el.getAttributeByName(NAME).getValue();
                     }

                 } else {
                     if (wrongNamespace != null) {
                         if (wrongNamespace.equals(el.getName().getNamespaceURI())) {
                             StartElementEvent ne = new StartElementEvent(new QName(xsdNamespace, el.getName().getLocalPart(), el.getName().getPrefix()), el.getAttributes(), el.getNamespaces(), el.getNamespaceContext(), el.getLocation(), el.getSchemaType());
                             e = ne;
                         }
                     }
                 }
                 break;
             }
             streamEventWriter.add(e);
         }
     }


     protected void messages(XMLStreamWriter w) throws XMLStreamException, IOException {
        message(w, "PipeLineInput", getInputTag().getRootTag(), targetNamespace);
        XmlValidator outputValidator = (XmlValidator) pipeLine.getOutputValidator();
        if (outputValidator == null) {
            LOG.debug("The PipeLine " + pipeLine + " has no output validator, this is a oneway wsdl");
        } else {
            RootTag out = getOutputTag();
            message(w, "PipeLineOutput", out.getRootTag(), out.xsd.nameSpace);
        }
        //message(w, "PipeLineFault", "error", "bla:bloe");

    }

     protected void message(XMLStreamWriter w, String name, String tag, String nameSpace) throws XMLStreamException, IOException {
         if (tag == null) throw new IllegalArgumentException("Tag cannot be null for " + nameSpace + " " + name);
         w.writeStartElement(WSDL, "message");
         w.writeAttribute("name", name);
         {
             w.writeEmptyElement(WSDL, "part");
             w.writeAttribute("name", tag);
             String typ = getXSD(nameSpace).pref + ":" + tag;
             w.writeAttribute("element", typ);
         }
         w.writeEndElement();

     }
     protected void portType(XMLStreamWriter w) throws XMLStreamException, IOException {
         w.writeStartElement(WSDL, "portType");
         w.writeAttribute("name", "PipeLine"); {
             w.writeStartElement(WSDL, "operation");
             w.writeAttribute("name", "Process"); {
                 w.writeEmptyElement(WSDL, "input");
                 w.writeAttribute("message", "ibis:PipeLineInput");

                 if (getOutputTag() != null) {
                     w.writeEmptyElement(WSDL, "output");
                     w.writeAttribute("message", "ibis:PipeLineOutput");
                 }
                 /*
                w.writeEmptyElement(WSDL, "fault");
                w.writeAttribute("message", "ibis:PipeLineFault");
                */

             }
             w.writeEndElement();
         }
         w.writeEndElement();
     }


     protected String getSoapAction() {
         try {
             AppConstants appConstants = AppConstants.getInstance();
             String sa = appConstants.getProperty("wsdl." + getName() + ".soapAction");
             if (sa != null) return sa;
             sa = appConstants.getProperty("wsdl.soapAction");
             if (sa != null) return sa;
         } catch (Throwable nic) {
             LOG.warn(nic);

         }
         return "defaultAction";
     }

     protected void binding(XMLStreamWriter w) throws XMLStreamException, IOException {
         w.writeStartElement(WSDL, "binding");
         w.writeAttribute("name", "SoapBinding");
         w.writeAttribute("type", "ibis:PipeLine"); {
             w.writeEmptyElement(SOAP_WSDL, "binding");
             w.writeAttribute("transport", SOAP_HTTP);
             w.writeAttribute("style", "document");

             w.writeStartElement(WSDL, "operation");
             w.writeAttribute("name", "Process"); {

                 w.writeEmptyElement(SOAP_WSDL, "operation");
                 w.writeAttribute("style", "document");
                 w.writeAttribute("soapAction", getSoapAction());

                 w.writeStartElement(WSDL, "input"); {
                     RootTag  input = getInputTag();
                     w.writeEmptyElement(input.xsd.nameSpace, input.getRootTag());
                     w.writeAttribute("use", "literal");
                 }
                 w.writeEndElement();

                 RootTag  outputTag = getOutputTag();
                 if (outputTag != null) {
                     w.writeStartElement(WSDL, "output"); {
                         w.writeEmptyElement(outputTag.xsd.nameSpace, outputTag.getRootTag());
                         w.writeAttribute("use", "literal");
                     }
                     w.writeEndElement();
                 }

                 /*
                 w.writeStartElement(WSDL, "fault"); {
                     w.writeEmptyElement(SOAP_WSDL, "error");
                     w.writeAttribute("use", "literal");
                 }
                 w.writeEndElement();
                 */
             }
             w.writeEndElement();
         }
         w.writeEndElement();
     }

     protected void service(XMLStreamWriter w, String servlet) throws XMLStreamException {
         w.writeStartElement(WSDL, "service");
         w.writeAttribute("name", getName()); {
             w.writeStartElement(WSDL, "port");
             w.writeAttribute("name", "SoapHttp");
             w.writeAttribute("binding", "ibis:SoapBinding"); {
                 w.writeEmptyElement(SOAP_WSDL, "address");
                 w.writeAttribute("location", servlet);

             }
             w.writeEndElement();
         }
         w.writeEndElement();
     }


     protected PipeLine getPipeLine() {
         return pipeLine;
     }

     protected RootTag getRootTag(XmlValidator xmlValidator, String defaultNamespace) throws IOException, XMLStreamException {
         if (xmlValidator == null) {
             throw new IllegalStateException("The adapter " + pipeLine + " has no validator");

         }
         String tag = xmlValidator.getRoot();
         List schemas = parseSchema(xmlValidator.getSchemaLocation());
         String xmlns = schemas.size() > 0 ? ((XSD) schemas.get(0)).nameSpace : defaultNamespace;
         if (xmlns == null) {
             throw new IllegalStateException("No namespace found for " + xmlValidator);
         }
         RootTag result = new RootTag(getXSD(xmlns), tag);
         if (tag == null) {
             LOG.warn("The validator " + xmlValidator + " has no root tag. I guess it is " + result.getRootTag());
         }
         return result;
     }

     protected RootTag getInputTag() throws IOException, XMLStreamException {
         return getRootTag((XmlValidator) getPipeLine().getInputValidator(), targetNamespace);
     }

     protected RootTag getOutputTag() throws IOException, XMLStreamException {
         XmlValidator outputValidator = (XmlValidator) getPipeLine().getOutputValidator();
         if (outputValidator != null) {
             return getRootTag((XmlValidator) getPipeLine().getOutputValidator(), null);
         } else {
             LOG.debug("Oneway");
             return null;
         }
     }

     private XMLStreamWriter createWriter(OutputStream out) throws XMLStreamException {
         return createWriter(out, indentWsdl);
     }

     static XMLStreamWriter createWriter(OutputStream out, boolean indentWsdl) throws XMLStreamException {
         XMLStreamWriter w = OUTPUT_FACTORY.createXMLStreamWriter(out, ENCODING);
         if (indentWsdl) {
             IndentingXMLStreamWriter iw = new IndentingXMLStreamWriter(w);
             iw.setIndent(" ");
             w = iw;
         }
         return w;
     }

     private XSD getXSD(String ns, String resource) {
         URL url = ClassUtils.getResourceURL(resource);
         if (url == null) throw new IllegalArgumentException("No such resource " + resource);
         for (Iterator i = xsds.iterator(); i.hasNext();) {
             XSD xsd = (XSD) i.next();

             if (xsd.nameSpace == null) {
                 if (xsd.url.equals(url)) {
                     return xsd;
                 }
             } else  {
                 if (xsd.nameSpace.equals(ns)){
                     return xsd;
                 }
             }
         }
         XSD xsd = new XSD("", ns, url, xsds.size() + 1);
         xsds.add(xsd);
         return  xsd;
     }

     public boolean isRecursiveXsds() {
         return recursiveXsds;
     }

     /**
      * Make an effort to collect all XSD's also the included ones in {@link #getXSDs()}
      * @param recursiveXsds
      */
     public void setRecursiveXsds(boolean recursiveXsds) {
         this.recursiveXsds = recursiveXsds;
         xsds = null;
     }

     public String getDocumentation() {
         return documentation;
     }

     public void setDocumentation(String documentation) {
         this.documentation = documentation;
     }

     public boolean isIncludeXsds() {
         return includeXsds;
     }

     public void setIncludeXsds(boolean includeXsds) {
         this.includeXsds = includeXsds;
     }

     static class RootTag {
         final XSD xsd;
         private final String root;
         RootTag(XSD xsd, String r) {
             this.xsd = xsd;
             this.root = r;
         }
         public String getRootTag() {
             return root == null ? xsd.firstTag : root;
         }

     }
     static class XSD implements Comparable {

         final String nameSpace;
         final URL url;
         final String pref;
         String firstTag;
         final String parentLocation;

         XSD(String parentLocation, String nameSpace, URL resource, int prefixCount) {
             this.parentLocation = parentLocation;
             this.pref = "ns" + prefixCount;
             this.nameSpace = nameSpace;
             url = resource;
             if (url == null) throw new IllegalArgumentException("No resource " + resource + " found");
         }

         //@Override
         public boolean equals(Object o) {
             if (o instanceof XSD) {
                 XSD other = (XSD) o;
                 return nameSpace.equals(other.nameSpace) && url.equals(other.url);
             } else {
                 return false;
             }
         }
         //@Override
         public int hashCode() {
             return nameSpace.hashCode();
         }

         //@Override
         public String toString() {
             return nameSpace + " " + url;
         }

         //@Override
         public int compareTo(Object o) {
             if (o == null) return 1;
             XSD x = (XSD) o;
             int c = nameSpace != null ? nameSpace.compareTo(x.nameSpace  == null ? "" : x.nameSpace) : 0;
             if (c != 0) return c;
             return url.toExternalForm().compareTo(x.url.toExternalForm());

         }
         public String getBaseUrl() {
             String u = url.toString();
             String baseUrl;
             if (url.getProtocol().equals("file")) {
                 baseUrl = u.substring(Wsdl.class.getResource("/").toString().length());
             } else {
                 baseUrl = u.substring(u.indexOf("!/") + 2, u.length());

             }
             baseUrl = baseUrl.substring(0, baseUrl.lastIndexOf('/') + 1);
             return baseUrl;
         }

         public String getName() {
             String u = url.toExternalForm();
             int slash = u.lastIndexOf('/');
             u = u.substring(slash + 1);
             try {
                 return URLDecoder.decode(u, "UTF-8");
             } catch (UnsupportedEncodingException e) {
                 // cannot happen, UTF-8 is supported
                 return u;
             }
         }

         public Set getImportXSDs(Set set) throws IOException, XMLStreamException {
             if (set == null) set = new HashSet();
             InputStream in = url.openStream();
             if (in == null) return null;
             XMLEventReader er = INPUT_FACTORY.createXMLEventReader(in, ENCODING);
             while (er.hasNext()) {
                 XMLEvent e = er.nextEvent();
                 switch (e.getEventType()) {
                 case XMLStreamConstants.START_ELEMENT:
                     StartElement el = e.asStartElement();
                     if (el.getName().equals(IMPORT) ||
                         el.getName().equals(INCLUDE)
                         ) {
                         Attribute schemaLocation = el.getAttributeByName(SCHEMALOCATION);
                         Attribute namespace  = el.getAttributeByName(NAMESPACE);
                         XSD x = new XSD(getBaseUrl(),
                             namespace == null ? null : namespace.getValue(),
                             ClassUtils.getResourceURL(getBaseUrl() + schemaLocation.getValue()), 0);
                         if (set.add(x)) {
                             x.getImportXSDs(set);
                         }
                     }
                     break;
                 }
             }
             return set;
         }

     }

     static class NamespaceCorrectingXMLStreamWriter extends StreamWriterDelegate {


         private final Map map;

         protected NamespaceCorrectingXMLStreamWriter(XMLStreamWriter out, Map map) {
             super(out);
             this.map = map;
         }

         //@Override
         public void writeAttribute(String prefix, String namespaceURI, String localName, String value) throws XMLStreamException {
             String correct = (String) map.get(namespaceURI);
             if (correct != null) {
                 namespaceURI = correct;
             }
             out.writeAttribute(prefix, namespaceURI, localName, value);
         }

         //@Override
         public void writeNamespace(final String prefix, String namespaceURI) throws XMLStreamException {
             String correct = (String) map.get(namespaceURI);
             if (correct != null) {
                 LOG.warn("Corrected namespace " + prefix + ":xmls=" + namespaceURI + " to " + prefix + ":" + correct);
                 namespaceURI = correct;
             }
             out.writeNamespace(prefix, namespaceURI);

         }

     }
     /*
     public void easywsdl(OutputStream out, String servlet) throws XMLStreamException, IOException, SchemaException, URISyntaxException {
         Description description = WSDLFactory.newInstance().newDescription(AbsItfDescription.WSDLVersionConstants.WSDL11);

         SchemaFactory fact = SchemaFactory.newInstance();
         Types t = description.getTypes();
         for (XSD xsd : getXsds()) {
             description.addNamespace(xsd.pref, xsd.nameSpace);
             SchemaReader sr = fact.newSchemaReader();
             Schema s = sr.read(xsd.url);
             t.addSchema(s);
         }
         InterfaceType it = description.createInterface();
         Operation o = it.createOperation();
         Input i = o.createInput();
         i.setName("IbisInput");
         //i.
         // s
         t.addOperation(it.createOperation());
         description.addInterface();
         Binding binding = description.createBinding();
         BindingOperation op = binding.createBindingOperation();
         //description.addBinding(binding);
     }
 */
 }
